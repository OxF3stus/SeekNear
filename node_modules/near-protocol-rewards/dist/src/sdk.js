"use strict";
/**
 * GitHub Rewards SDK
 *
 * A simplified rewards system that tracks GitHub development activity
 * and calculates rewards based on contribution metrics.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorCode = exports.BaseError = exports.GitHubRewardsSDK = void 0;
const events_1 = require("events");
const github_1 = require("./collectors/github");
const errors_1 = require("./types/errors");
const logger_1 = require("./utils/logger");
const rate_limiter_1 = require("./utils/rate-limiter");
const config_validator_1 = require("./utils/config-validator");
const github_2 = require("./validators/github");
class GitHubRewardsSDK extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.isTracking = false;
        const validationResult = (0, config_validator_1.validateConfig)(config);
        if (!validationResult.isValid) {
            const errorMessage = validationResult.errors[0]?.message || "Invalid configuration";
            throw new errors_1.BaseError(errorMessage, errors_1.ErrorCode.INVALID_CONFIG, {
                errors: validationResult.errors,
            });
        }
        this.config = config;
        this.logger = config.logger || new logger_1.ConsoleLogger();
        const rateLimiter = new rate_limiter_1.RateLimiter({
            maxRequestsPerSecond: config.maxRequestsPerSecond || 5,
        });
        this.validator = new github_2.GitHubValidator({
            logger: this.logger,
            maxCommitsPerDay: 15,
            minAuthors: 1,
            minReviewPrRatio: 0.5,
        });
        this.collector = new github_1.GitHubCollector({
            token: config.githubToken,
            repo: config.githubRepo,
            logger: this.logger,
            rateLimiter,
        });
    }
    async startTracking() {
        if (this.isTracking) {
            return;
        }
        try {
            await this.collector.testConnection();
            this.isTracking = true;
            this.emit("tracking:started");
        }
        catch (error) {
            this.logger.error("Failed to start tracking", { error });
            throw error;
        }
    }
    async stopTracking() {
        if (!this.isTracking) {
            return;
        }
        this.isTracking = false;
        this.emit("tracking:stopped");
    }
    async getMetrics() {
        try {
            const metrics = await this.collector.collectMetrics();
            const validation = this.validator.validate(metrics);
            const processed = {
                github: metrics,
                score: {
                    total: 0,
                    breakdown: {
                        commits: 0,
                        pullRequests: 0,
                        reviews: 0,
                        issues: 0,
                    },
                },
                timestamp: Date.now(),
                collectionTimestamp: metrics.metadata.collectionTimestamp,
                validation,
                metadata: {
                    source: "github",
                    projectId: metrics.metadata.projectId,
                    collectionTimestamp: metrics.metadata.collectionTimestamp,
                    periodStart: Date.now() - 7 * 24 * 60 * 60 * 1000, // 1 week ago
                    periodEnd: Date.now(),
                },
                periodStart: Date.now() - 7 * 24 * 60 * 60 * 1000,
                periodEnd: Date.now(),
            };
            this.emit("metrics:collected", processed);
            return processed;
        }
        catch (error) {
            this.logger.error("Failed to collect metrics", { error });
            this.emit("error", error);
            return null;
        }
    }
}
exports.GitHubRewardsSDK = GitHubRewardsSDK;
var errors_2 = require("./types/errors");
Object.defineProperty(exports, "BaseError", { enumerable: true, get: function () { return errors_2.BaseError; } });
Object.defineProperty(exports, "ErrorCode", { enumerable: true, get: function () { return errors_2.ErrorCode; } });
