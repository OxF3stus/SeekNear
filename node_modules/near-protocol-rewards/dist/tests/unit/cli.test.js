"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const fs_1 = __importDefault(require("fs"));
const cli_1 = require("../../src/cli");
const logger_1 = require("../../src/utils/logger");
// Mock the logger
globals_1.jest.mock('../../src/utils/logger', () => ({
    ConsoleLogger: globals_1.jest.fn().mockReturnValue({
        info: globals_1.jest.fn(),
        error: globals_1.jest.fn(),
        debug: globals_1.jest.fn(),
        warn: globals_1.jest.fn()
    })
}));
// Mock fs
globals_1.jest.mock('fs', () => ({
    mkdirSync: globals_1.jest.fn(),
    writeFileSync: globals_1.jest.fn()
}));
// Mock path
globals_1.jest.mock('path', () => ({
    join: (...args) => args.join('/')
}));
describe('CLI', () => {
    let logger;
    let mockExit;
    const expectedPath = '/fake/path/.github/workflows/near-rewards.yml';
    beforeEach(() => {
        globals_1.jest.clearAllMocks();
        logger = new logger_1.ConsoleLogger();
        mockExit = globals_1.jest.spyOn(process, 'exit').mockImplementation(() => undefined);
        globals_1.jest.spyOn(process, 'cwd').mockReturnValue('/fake/path');
    });
    describe('init command', () => {
        it('should create workflow directory and file with correct content', async () => {
            await cli_1.program.parseAsync(['node', 'test', 'init']);
            // Verify directory creation
            expect(fs_1.default.mkdirSync).toHaveBeenCalledWith('/fake/path/.github/workflows', { recursive: true });
            // Verify file content
            expect(fs_1.default.writeFileSync).toHaveBeenCalledWith(expectedPath, expect.stringContaining('calculate-rewards:'));
            // Verify success message
            expect(logger.info).toHaveBeenCalledWith('âœ… Created GitHub Action workflow');
        });
        it('should handle initialization errors', async () => {
            fs_1.default.mkdirSync.mockImplementation(() => {
                throw new Error('Failed to create directory');
            });
            await cli_1.program.parseAsync(['node', 'test', 'init']);
            expect(logger.error).toHaveBeenCalledWith('Failed to initialize:', { message: 'Failed to create directory' });
            expect(mockExit).toHaveBeenCalledWith(1);
        });
    });
    describe('command validation', () => {
        it('should require environment variables for calculate', async () => {
            delete process.env.GITHUB_TOKEN;
            delete process.env.GITHUB_REPO;
            await cli_1.program.parseAsync(['node', 'test', 'calculate']);
            expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Missing required environment variables'));
            expect(mockExit).toHaveBeenCalledWith(1);
        });
    });
});
