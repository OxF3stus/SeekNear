"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const cli_1 = require("../../src/cli");
const logger_1 = require("../../src/utils/logger");
// Mock the logger
globals_1.jest.mock('../../src/utils/logger', () => ({
    ConsoleLogger: globals_1.jest.fn().mockReturnValue({
        info: globals_1.jest.fn(),
        error: globals_1.jest.fn(),
        debug: globals_1.jest.fn(),
        warn: globals_1.jest.fn()
    })
}));
// Mock fs and path
globals_1.jest.mock('fs');
globals_1.jest.mock('path');
describe('CLI', () => {
    let logger;
    let mockExit;
    beforeEach(() => {
        globals_1.jest.clearAllMocks();
        // Setup logger mock
        logger = new logger_1.ConsoleLogger();
        // Mock process.exit with correct SpyInstance typing
        mockExit = globals_1.jest.spyOn(process, 'exit').mockImplementation(() => undefined);
        // Mock process.cwd
        globals_1.jest.spyOn(process, 'cwd').mockReturnValue('/fake/path');
        // Correctly type and mock path.join
        const mockedJoin = path_1.default.join;
        mockedJoin.mockImplementation((...args) => args.join('/'));
        // Clear environment variables
        delete process.env.GITHUB_TOKEN;
        delete process.env.GITHUB_REPO;
    });
    afterEach(() => {
        globals_1.jest.restoreAllMocks();
    });
    describe('init command', () => {
        it('should create workflow directory and file', async () => {
            // Mock fs functions
            fs_1.default.mkdirSync.mockImplementation(() => undefined);
            fs_1.default.writeFileSync.mockImplementation(() => undefined);
            await cli_1.program.parseAsync(['node', 'test', 'init']);
            expect(fs_1.default.mkdirSync).toHaveBeenCalledWith('/fake/path/.github/workflows', { recursive: true });
            expect(fs_1.default.writeFileSync).toHaveBeenCalledWith('/fake/path/.github/workflows/near-rewards.yml', expect.stringContaining('name: NEAR Protocol Rewards Tracking'));
            expect(logger.info).toHaveBeenCalledWith('âœ… Created GitHub Action workflow');
        });
        it('should handle initialization errors', async () => {
            fs_1.default.mkdirSync.mockImplementation(() => {
                throw new Error('Failed to create directory');
            });
            await cli_1.program.parseAsync(['node', 'test', 'init']);
            expect(logger.error).toHaveBeenCalledWith('Failed to initialize:', { message: 'Failed to create directory' });
            expect(mockExit).toHaveBeenCalledWith(1);
        });
    });
});
